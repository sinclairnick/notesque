// Scorelang Visual Tests
// Tests that render scores with OSMD and compare SVG output
//
// Uses Vitest's built-in happy-dom environment with canvas polyfill for OSMD

import { describe, it, expect, beforeEach, beforeAll } from 'vitest';
import { parseScoreToAST } from '../score-parser';
import { transpileToMusicXML } from '../score-musicxml';
import { CORE_EXAMPLES } from './fixtures/spec-examples';

// OSMD will be loaded dynamically since it needs DOM to be set up first
let OSMD: typeof import('opensheetmusicdisplay').OpenSheetMusicDisplay;
let osmdLoaded = false;

// Set up canvas and globals for OSMD's sky-bottom line calculator
beforeAll(async () => {
	try {
		// Import canvas package
		const { createCanvas, Canvas } = await import('canvas');

		// Set up global Canvas class for OSMD
		(global as any).Canvas = Canvas;

		// Polyfill document.createElement to return canvas elements that work
		const originalCreateElement = document.createElement.bind(document);
		document.createElement = function (tagName: string, options?: any): any {
			const element = originalCreateElement(tagName, options);

			if (tagName.toLowerCase() === 'canvas') {
				// Create a real Canvas object from the canvas package
				const canvas = createCanvas(1200, 800);

				// Copy the canvas's getContext to the DOM element
				(element as any).getContext = function (contextType: string) {
					return canvas.getContext(contextType as any);
				};
				(element as any).width = 1200;
				(element as any).height = 800;
			}

			return element;
		};

		// Mock createImageBitmap which OSMD may try to use
		if (typeof globalThis.createImageBitmap === 'undefined') {
			(globalThis as any).createImageBitmap = async () => ({ width: 0, height: 0, close: () => { } });
		}
	} catch (e) {
		console.error('Failed to set up canvas for OSMD:', e);
		throw e;
	}
});

// Helper to render Scorelang source to SVG
async function scorelangToSVG(source: string): Promise<string> {
	const { ast, errors } = parseScoreToAST(source);
	if (!ast || errors.length > 0) {
		throw new Error(`Parse failed: ${errors.map((e) => e.message).join(', ')}`);
	}
	const xml = transpileToMusicXML(ast);
	return renderMusicXMLToSVG(xml);
}

// Render MusicXML to SVG using OSMD
async function renderMusicXMLToSVG(musicXml: string): Promise<string> {
	// Import OSMD dynamically
	if (!osmdLoaded) {
		const osmdModule = await import('opensheetmusicdisplay');
		OSMD = osmdModule.OpenSheetMusicDisplay;
		osmdLoaded = true;
	}

	// Create container in happy-dom's document
	const container = document.createElement('div');
	container.id = 'osmd-test-container';
	container.style.width = '1200px';
	container.style.height = '2000px';
	document.body.appendChild(container);

	// Override offsetWidth/offsetHeight since happy-dom doesn't compute layout
	Object.defineProperty(container, 'offsetWidth', { value: 1200, configurable: true });
	Object.defineProperty(container, 'offsetHeight', { value: 2000, configurable: true });

	try {
		// Create OSMD instance with settings that work in headless mode
		const osmd = new OSMD(container, {
			autoResize: false,
			backend: 'svg',
			drawTitle: false,
			drawSubtitle: false,
			drawComposer: false,
			drawCredits: false,
			drawPartNames: false,
		});

		// Load and render
		await osmd.load(musicXml);
		osmd.render();

		// Extract SVG
		const svg = container.querySelector('svg');
		if (!svg) {
			throw new Error('No SVG generated by OSMD');
		}

		return svg.outerHTML;
	} finally {
		// Clean up
		document.body.removeChild(container);
	}
}

// Validate SVG has proper structure
function validateSVGOutput(svg: string): { valid: boolean; errors: string[] } {
	const errors: string[] = [];

	if (!svg.includes('<svg')) {
		errors.push('No SVG root element found');
	}

	if (!svg.includes('</svg>')) {
		errors.push('SVG not properly closed');
	}

	// Check for at least some graphical content
	const hasContent =
		svg.includes('<path') ||
		svg.includes('<ellipse') ||
		svg.includes('<rect') ||
		svg.includes('<line') ||
		svg.includes('<polygon');

	if (!hasContent) {
		errors.push('SVG contains no graphical elements');
	}

	return {
		valid: errors.length === 0,
		errors,
	};
}

// Extract structural info from SVG for stable comparison
function extractSVGStructure(svg: string): string[] {
	const elements: string[] = [];

	// Count different element types
	const noteMatches = svg.match(/<ellipse[^>]*>/g);
	if (noteMatches) {
		elements.push(`note-heads: ${noteMatches.length}`);
	}

	const pathMatches = svg.match(/<path[^>]*>/g);
	if (pathMatches) {
		elements.push(`paths: ${pathMatches.length}`);
	}

	const textMatches = svg.match(/<text[^>]*>[^<]+<\/text>/g);
	if (textMatches) {
		elements.push(`text-elements: ${textMatches.length}`);
	}

	return elements;
}

describe('Visual: OSMD Rendering', () => {
	beforeEach(() => {
		// Clean up any leftover containers
		const containers = document.querySelectorAll('#osmd-test-container');
		containers.forEach((c) => c.remove());
	});

	describe('Basic Rendering', () => {
		it('renders basic notes to valid SVG', async () => {
			const svg = await scorelangToSVG(CORE_EXAMPLES.basicNotes);
			const result = validateSVGOutput(svg);
			expect(result.valid, result.errors.join(', ')).toBe(true);
		});

		it('renders accidentals', async () => {
			const svg = await scorelangToSVG(CORE_EXAMPLES.accidentals);
			const result = validateSVGOutput(svg);
			expect(result.valid, result.errors.join(', ')).toBe(true);
		});

		it('renders durations', async () => {
			const svg = await scorelangToSVG(CORE_EXAMPLES.durations);
			const result = validateSVGOutput(svg);
			expect(result.valid, result.errors.join(', ')).toBe(true);
		});

		it('renders chords', async () => {
			const svg = await scorelangToSVG(CORE_EXAMPLES.chords);
			const result = validateSVGOutput(svg);
			expect(result.valid, result.errors.join(', ')).toBe(true);
		});

		it('renders rests', async () => {
			const svg = await scorelangToSVG(CORE_EXAMPLES.rests);
			const result = validateSVGOutput(svg);
			expect(result.valid, result.errors.join(', ')).toBe(true);
		});
	});

	describe('Multiple Staves', () => {
		it('renders two staves (piano grand staff)', async () => {
			const svg = await scorelangToSVG(CORE_EXAMPLES.twoStaves);
			const result = validateSVGOutput(svg);
			expect(result.valid, result.errors.join(', ')).toBe(true);
		});
	});

	describe('Dynamics and Articulations', () => {
		it('renders dynamics', async () => {
			const svg = await scorelangToSVG(CORE_EXAMPLES.dynamics);
			const result = validateSVGOutput(svg);
			expect(result.valid, result.errors.join(', ')).toBe(true);
		});

		it('renders articulations', async () => {
			const svg = await scorelangToSVG(CORE_EXAMPLES.articulations);
			const result = validateSVGOutput(svg);
			expect(result.valid, result.errors.join(', ')).toBe(true);
		});
	});

	describe('Complete Example', () => {
		it('renders the complete spec example', async () => {
			const svg = await scorelangToSVG(CORE_EXAMPLES.completeExample);
			const result = validateSVGOutput(svg);
			expect(result.valid, result.errors.join(', ')).toBe(true);
		});
	});

	describe('SVG Snapshots', () => {
		it('basic notes structure snapshot', async () => {
			const svg = await scorelangToSVG(CORE_EXAMPLES.basicNotes);
			const structure = extractSVGStructure(svg);
			expect(structure).toMatchSnapshot('basic-notes-structure');
		});

		it('chord structure snapshot', async () => {
			const svg = await scorelangToSVG(CORE_EXAMPLES.chords);
			const structure = extractSVGStructure(svg);
			expect(structure).toMatchSnapshot('chords-structure');
		});

		it('two staves structure snapshot', async () => {
			const svg = await scorelangToSVG(CORE_EXAMPLES.twoStaves);
			const structure = extractSVGStructure(svg);
			expect(structure).toMatchSnapshot('two-staves-structure');
		});

		it('complete example structure snapshot', async () => {
			const svg = await scorelangToSVG(CORE_EXAMPLES.completeExample);
			const structure = extractSVGStructure(svg);
			expect(structure).toMatchSnapshot('complete-example-structure');
		});
	});
});
